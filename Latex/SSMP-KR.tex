\documentclass[review,3p,times,authoryear,12pt]{elsarticle}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{algorithm}
\usepackage{graphicx,subfigure}
\usepackage{clrscode3e}
\usepackage{enumerate}
\usepackage{multirow}
\graphicspath{{figure/}}
\newtheorem{proposition}{Proposition}


\begin{document}
\begin{frontmatter}
\newpage

\title{The Stowage Stack Minimization Problem with K-Rehandle Constraint}
\author[shu]{Ning Wang}
\ead{ningwang@shu.edu.cn}

\author[shu]{Shanhui Ke}

\author[syu]{Zizhen Zhang\corref{corl}}
\ead{zhangzizhen@gmail.com}

\address[shu]{
Department of Information Management, School of Management, Shanghai University, Shanghai, China
}
\address[syu]{
School of Data and Computer Science, Sun Yat-Sen University, China
}
\cortext[corl]{Corresponding author. Fax: +852 ********, Phone: +852 ********}

\begin{abstract}
The Stowage Stack Minimization Problem (SSMP) investigates a stowage planning problem when carriers have the obligation to ship all the given containers in different ports, with the objective to utilize the fewest number of stacks on the ship. This problem has realistic usefulness since it can help shipping forwarders estimate shipping space of each shippers.
To our best knowledge, we propose SSMP for the first time in the academic community.

In this paper, we talk about SSMP with $K$-rehandle constraint. A heuristic algorithm is put forward to construct solutions. We discuss the theoretical performance guarantee of the algorithm using mathematical inequations and induction.
To evaluate the actual performance of our algorithm, we conduct experiments on a set of instances with practical size and compare the results when different values of $K$ are selected.
What's more, instances with different values of ports, containers and heights have been tested to make sure the universality of our algorithm.
\end{abstract}

\begin{keyword}
Containership stowage planning\sep stack minimization \sep K-rehandles \sep constructive heuristic
\end{keyword}
\end{frontmatter}


\section{Introduction}
\label{sec:i}
International trade plays an important role in promoting the development of world economy.
Maritime transport is the backbone of globalization and lies at the heart of cross-border transport networks that support supply chains and enable international trade.
Nowadays, over 80\% of world trade is carried by the maritime freight industry, which operates the container transportation business \citep{zhang2016multiobjective}.
In 2015, world seaborne trade volumes surpassed 10 billion tons shown in ~\cite{unctad2016}.

Container-shipping is a kind of modern transportation tool which has a lot of advantages in speed, security, and quality comparing with the break-bulk cargo ship.
Containerization is an important driver of the global economy, and the container has become a mainstay of worldwide trade.
According to World Shipping Council, around 52\% of the value of world international seaborne trade today is being moved in containers.
This mode is deeply accepted by shippers and carriers, and is becoming the main trend of freightage in the world.
It has resulted in a tremendous growth of the maritime freight industry and it shows powerful vitality and promising prospects.

With the development of container-shipping, more and more containers are transported by sail.
Over the past decades there has been a continuous increase in demand for cost efficient containerized transportation.
Thus, it makes higher research demand.
The container stowage plan is a pivotal link to containers transportation, and the objective of which is to draw a plan of loading and discharging sequence of containers for containership in \cite{zhang2008review}.
The most frequently used addressing notation for storage locations in a container ship is the bay-row-tier system.
The cargo space of a container ship is split into several 20-ft-long areas.
These areas are termed as 20-ft bays. Figure \ref{fig 1:graph} reproduced from \cite{delgado2012constraint} shows a diagram of containership.
\begin{figure}[htbp]
\center
\setlength{\abovecaptionskip}{10pt}
\resizebox{0.5\textwidth}{!}{\includegraphics{figure/Arrangement_of_cargo_space.png}}
\caption{The arrangement of cargo space in a container vessel.}
\label{fig 1:graph}
\end{figure}

Each bay consists of container stacks placed along the width of ship.
Stacks in a bay are indexed by a row number.
%All bays are divided into an over deck and an deck area, separated by structures called hatches.
The position for one 20-ft container in the ship is uniquely indexed by (bay, row, tier), called a slot.
%However, slot in this paper is indexed by (stack, tier) for the sake of research convenience.
In addition, for some ships, two contiguous 20-ft bays form a 40-ft bay which can be used to accommodate 40-ft containers.

A ship usually calls a sequence of ports and containers are loaded and unloaded at each port by cranes in a last-in-last-out (LIFO) manner.
Rehandles arise either when we want to unload containers destined for current port which however are beneath those destined for subsequent ports, or when we want to reorder the sequence of containers to prevent more rehandles in the future.
Rehandles are expensive, since on one hand terminals directly charge the carriers for such operations, on the other hand, rehandles make ships dwell at terminals longer, inducing more berthing cost.
%In addition, each container has a weight which affect the balance and stability of ships.
Actual examples show that containership stowage plans not only influence the income of shipping company from transportation but also have direct relation to the safety of ships and freights.
The problems have troubled and aroused the interests of both scholars and commercial shipping organization in many countries since 1970s~\citep{webster1970container}.
Most of previous research on stowage planning focus on how to minimize the number of rehandles \citep{ding2015stowage,zhang2016multiobjective,zehendner2017algorithm}.

In this paper, we investigate the problem from a new perspective. We deal with Stowage Stack Minimization Problem (SSMP) which minimizes the number of used stacks.
The problem has realistic meaning. In the real world, a carrier/forwarder may collect a few containers in a time interval and want to evaluate needed space (stacks), in order to estimate available space left.
Or on the contrary, a carrier/forwarder wants to receive provisional shipment orders as many as possible while reserve enough space for regular shipment orders.
Our algorithm provides them an indicator to achieve such goals.

The contribution of our paper lies in three aspects.
First, to the best of our knowledge, our paper considers number of stacks used for the first time, and this is a very practical consideration.
As talked before, previous research usually focus on how to reduce the rehandles or shifts.
Second, we analyze SSMP and give upper and lower bounds of SSMP. The bounds pave a way for future study.
Third, we propose a heuristic algorithm to solve SSMP and the algorithm has a performance guarantee.

The remainder of this paper is organized as follows: we review extant research works in Section~\ref{sec:lr}. The formal definition of SSMP and its properties are provided in Section~\ref{sec:pd}.
In Section~\ref{sec:algo}, we present our heuristic algorithm and the performance analysis.
Experiments are illustrated in Section~\ref{sec:ea}. Concluding remarks close the paper in Section~\ref{sec:con}.

\section{Literature review}
\label{sec:lr}
The container handling problems can be divided into two streams based on the container handling locations occurred; one is container management at terminals, and the other is containership stowage planning problems (CSP).
The problem discussed in this paper belongs to the latter.
Research methods of CSP can be divided into six categories: simulation methods based on probability, expert systems, decision support systems, heuristic procedures, mathematical programming approach and evolutionary computation. Research about the last three methods are more widely used now and we focus on them in the following review of relevant works.

\cite{webster1970container} first tried to solve the problem by using simulation methods with the help of computer. 
They put forward a heuristic algorithm that could create a random stowage plan.
\cite{shields1984containership} introduced a computer preplanning system (CAPS) which had been used by American President Lines.
The CAPS produced stowage plans by using Monte Carlo theory.

\cite{dillingham1986application} introduced their researches on expert system of stowage based on rules.
Each of the suggested container movements was displayed graphically as the decisions were made.

\cite{wilson2001container} outlined a computer system that generated good sub-optimal solutions to the stowage pre-planning problem.
The methodology progressively refined the arrangement of containers within the cargo-space of a container ship until each container is specifically allocated to a stowage location.

Three heuristic rules were used to assign gradually each type of containers to slots of the ship by four steps in \cite{scott1978loading}, while the shifting problem had not been considered in their model.
Tabu search was employed to obtain an optimal solution in \cite{wilson2001container} and \cite{bortfeldt2003parallel}.
The Ship Stowage Planning Problem had been addressed in \cite{monaco2014terminal}.
They proposed a Binary Integer Model for the minimization of the transportation times of the containers and the yard-shifts and they developed a Tabu Search Algorithm for finding sub-optimal solutions to the problem.
\cite{ding2015stowage} developed a heuristic algorithm which can generate stowage plans with a reasonable number of shifts for such problems.
The algorithm, verified by extensive computational experimentations, performed better than the Suspensory Heuristic Procedure (SH algorithm) in \cite{avriel1998stowage}, which was a dynamic slot-assignment scheme that terminated with a stowage plan, and was one of the leading heuristic algorithms for such stowage planning problem.

\cite{botter1991stowage} created a model called complete mathematical model for the stowage plan problem, which used binary decision variables to determine the containers unloading and loading sequence for each port.
\cite{avriel1998stowage} presented a 0-1 binary linear programming formulation based on minimizing the number shifting in a single bay of a ship calling at a given number of ports.
However, the large number of binary variables and constraints made binary linear programming formulation for such problems impracticable for real life problems.
\cite{avriel2000container} focused on stowage planning in order to minimize the number of unproductive shifts.
A binary linear programming (LP) model was formulated without considering ship's stability and other real-life constraints.
\cite{haghani2001model} proposed a MIP model for developing loading plans in order to minimize the time that a vessel spent at port, and the container handling cost which shifts caused by was highly influenced by the number of unproductive but necessary an unsatisfactory arrangement of containers.
In \cite{ambrosino2004stowing}, the problem of stowing containers into a containership had been faced by evaluating an exact 0-1 Linear Programming model, which was not practically useful for large cases.
\cite{ambrosino2015mip} proposed a Mixed  Integer  Programming (MIP) heuristic aimed at determining stowage plans in circular routes for container ships so as to give support for the ship coordinator and the terminal planner.
In \cite{parreno2016grasp}, they focused on the slot planning phase and presented a Constraint Programming and Integer Programming model for stowing a set of containers in a single bay section.

Algorithm of evolutionary computation came from Darwin¡¯s biologic theory of evolution. 
The presented hybrid GA for loading a single container in \cite{bortfeldt2001hybrid} was particularly suitable for strongly heterogeneous containers stowage problems.
The algorithm took account of some constraints which were relevant in practice.
\cite{dubrovsky2002genetic}  used a GA for solving the stowage planning problem of minimizing the number of container movements.
Search space was significantly reduced by a compact and efficient encoding scheme.
Ship stability criteria were reflected by appropriate constraints.
Simulation runs demonstrated the efficiency and flexibility of the GA-based approach.
\cite{kammarti2009evolutionary} proposed an efficient genetic algorithm which consists on selecting two chromosomes (parent) from an initially constructed population using a roulette wheel technique.
The variant tackled in \cite{cohen2017container} involved several constraints, inspired by real-life problems and application found in the literature.

Container stowage problem with rehandles constraint will be introduced in this paragraph.
\cite{malucelli2008stack} investigated stack reordering strategies aiming at minimizing the number of loading and unloading operations.
The complexity of stowage planning problem is investigated in \cite{tierney2014complexity} and it showed that the capacitated k-shift problem is solvable in polynomial time for any choice of stacks and stacks capacities.
A multi-objective ship stowage planning problem was researched by \cite{zhang2016multiobjective} and it aimed to optimize the ship stability and the number of rehandles simultaneously.

To the best of our knowledge, only \cite{avriel2000container} and \cite{jensen2010complexity} discussed the stowage stack minimization and its connection with the chromatic number of circle graphs when the stack height is unlimited apart from the SSMP-ZR researched by \cite{wang2014stowage}.
 

\section{Problem description and properties}
\label{sec:pd}
\subsection{Problem description and notation}
We put forward SSMP in this subsection.
Literally speaking, SSMP is a variant of CSP.
A ship starts its journey at port 1 and sequentially visits port 2, 3, ..., $P$. We assume the ship stops at port $P$.
$N$ containers are shipped along the journey.
At each port, the containers destined to the current port are discharged, and the containers await on yard are loaded to the ship.
We use $O(c)$ and $D(c)$ to denote the original and destination ports of container $c$, respectively. Accordingly, the itinerary is represented by a tuple $\{O(c), D(c)\}$.
Given $N$ containers to be shipped, the objective of SSMP is to figure out a stowage planning so as to minimize needed stacks.

If two containers $c1$ and $c2$ satisfy $O(c1)<O(c2)<D(c1)<D(c2)$, and $c2$ is placed above $c1$, then one \textit{rehandle} occurs, as we have to move $c2$ to the yard temporally for retrieving $c1$. Besides, containers above $c2$ also have to be moved, and therefore also extra rehandles occur.
In this paper, we extend SSMP with zero rehandle constraint in \cite{wang2014stowage}, assuming that $K$ rehandles are allowed.



Other assumptions assumed in this paper:
\begin{itemize}
\item Containers loaded are uniform standard 20-ft containers;
\item The information of $N$ containers are known in advance;
\item The containership is large enough to accommodate all the given containers;
\item Each stack can hold at most $H$ vertically piled containers, i.e., the height limit of every stack is $H$;
\item The balance of the containership can be resolved by assigning container stacks and water-ballast; hence, the balance is not considered when minimizing container stacks.
\end{itemize}

If the number of containers in a non-empty stack is less than $H$, the stack is termed as a \textit{partial} stack; otherwise it is a \textit{full} stack.
If rehandle occurs, containers above are called \textit{blocking containers} and the to-be-retrieved container is called \textit{target container}.
When moving blocking containers back to the ship, there is no guarantee that they will be returned to their original slots.

A feasible solution to the SSMP is represented by a sequence of operations. Each operation indicates the number of container and the accommodating stack. Especially, the yard is term as stack 0. Moving a container $c$ to stack 0 means that $c$ is a blocking container and moved temporally on the yard.

%\subsection{Equivalent linear route}
%\begin{proposition}
%An instance of circular route can be converted into an instance of linear route.
%\end{proposition}
%
%\begin{proof}
%Supposing that a ship starts its journey at port 1 and sequentially visits port 2, ..., $P$, 1, 2, ..., $P$, 1, ....
%There are $P*(P-1)$ types of possible itineraries, which are:
%\begin{itemize}
%\item $\{1,2\},\{1,3\}...,\{1, P-1\},\{1,P\}$;
%\item $\{2,3\},\{2,4\}...,\{2, P\},\{2,1\}$;
%\item $...$;
%\item $\{P-1,P\},\{P-1,1\}...,\{P-1, P-3\},\{P-1,P-2\}$;
%\item $\{P,1\},\{P,2\}...,\{P, P-2\},\{P,P-1\}$;
%\end{itemize}
%Since the port number is only a reference to the port, for itineraries with $O(c)>D(c)$, we rename the destination port $D(c)$ with $D(c)+P$. Hence, the possible itineraries become
%\begin{itemize}
%\item $\{1,2\},\{1,3\}...,\{1, P-1\},\{1,P\}$;
%\item $\{2,3\},\{2,4\}...,\{2, P\},\{2,P+1\}$;
%\item $...$;
%\item $\{P-1,P\},\{P-1,P+1\}...,\{P-1, 2P-3\},\{P-1,2P-2\}$;
%\item $\{P,P+1\},\{P,P+2\}...,\{P, 2P-2\},\{P,2P-1\}$;
%\end{itemize}
%
%Now we consider a linear instance. Assume a ship visits port 1, 2, ..., $P$, $P+1$, $P+2$, ..., $2P-1$, then possible itineraries include $\{1,2\},\{1,3\},...,\{1,2P-1\},\{2,3\},...,\{2,2P-1\},...,\{2P-2,2P-1\}$. The set of itineraries of a $P$-port circular instance are only a subset of that of a ($2P-1$)-port linear instance.
%
%Based on the above analysis, we can conclude that an instance of circular route can be converted to an instance of linear route by renaming $D(c)$ with $D(c)+P$ for itineraries with $O(c)>D(c)$.
%
%%There is another approach we can figure out to solve the circular route problem.
%%After going across port 1 in each circle, we reset the origin port of containers remained in vessel as port 1.
%%For example, containers from port 3 to the port 2 in the next circle will be containers from 1 to port 2 after going across port 1 in the next circle.
%%Thus, it only exists the port from port 1 to port $P$.
%\end{proof}
%
%\begin{proposition}
%The needed number of stacks for an instance of circular route is a finite number.
%\end{proposition}


\subsection{Integer model}
For the special case with zero rehandle, we only need to consider the loading process. For the unloading process, containers can be discharged in order without rehandles. The following IP model decides the accommodating stack of each container.
\begin{small}
\begin{align}
& (IP)~~\min\hspace{6pt}\sum_{s=1}^{S} y_s\notag\\
& \mathrm{s.t.}\hspace{11pt}\sum_{s=1}^{S} x_{is}=1, ~\forall 1\le i \le N \label{eqn:1}\\
%\mbox{s.t.~}& \sum_{c=1}^{C} x_{ic}=1, ~\forall 1\le i \le m \label{eqn:1}\\
& \hspace{24pt}\sum_{i=1}^{N} x_{is}\le M y_s, ~\forall 1\le s \le S	\label{eqn:2}\\
& \hspace{2pt}\sum_{i:O(i)\le p\le D(i)-1} x_{is}\le H, ~\forall 1\le s\le S, 1\le p\le P		\label{eqn:3}\\
& x_{is}+x_{js}\le 1, ~\forall 1\le s\le S, 1\le i,j\le N, O(j)<O(i)<D(j)<D(i)	\label{eqn:4}\\
& x_{is}, y_s \in \{0,1\}, ~\forall 1\le s\le S,1\le i,j\le N
\end{align}
\end{small}

In the above model, $M$ is a sufficiently large number and $S$ is the number of stacks on the ship.
$x_{is}$ is a binary decision variable which is equal to 1 if container $i$ is loaded to stack $s$, and 0 otherwise.
$y_s$ is a binary decision variable that is equal to 1 if stack $s$ is used for stowage, and 0 otherwise.
$O(i)$ and $D(i)$ indicate the shipping leg of container $i$.
The objective minimizes the number of stacks used.
Constraints (\ref{eqn:1}) ensure that each container $i$ is loaded to only one stack.
Constraints (\ref{eqn:2}) guarantee that containers can only be loaded to used stacks.
Constraints (\ref{eqn:3}) assure that at each port $p$, the number of containers in stack $s$ does not exceed $H$.
Constraints (\ref{eqn:4}) avoid rehandle requiring that container $i$ is prohibited to block container $j$ in the same stack when $O(j)<O(i)<D(j)<D(i)$.

The IP solution can be converted into a complete loading plan: start from port $p=1$ to port $p=P$. At port $p$, containers are sorted in a descending order of destination ports. Each container $i$ is loaded to the top of its corresponding stack $s^*$ which satisfies $x_{is^*}=1$.

For the IP model of general SSMP, it is hard to build a model.
Since there are rehandles, we have to move blocking containers on the yard and back to the ship.
The stacks of blocking containers are not necessarily the original slots.
If we want to model the slots of blocking containers, we have to set variable $x_{ctl}$ that indicates the slot $t$ of a container $c$ at a layout $l$.
We do not know which containers are blocking containers in advance, therefore the domain of $c$ is the whole set of $N$ containers.
Especially, whenever we load or discharge a container, it forms a layout.
In addition, we do not know the number of layouts in advance.
All in all, the number of slots, containers, and layouts are numerous. Apart from other variables and constraints, the number of variable $x_{ctl}$ alone is too large to make the model meaningful and solvable.

\section{Methodology}
\label{sec:algo}
In this section, we will talk about the heuristic algorithm to solve the SSMP as well as the performance guarantee of the algorithm.
%The heuristic algorithm uses a greedy rule to decide the loading and unloading operations for each container in each port along the voyage.

%For the sake of description, we will use some notations presented in the following Table \ref{tab:1} before we begin to introduce our algorithm.
%If the allowed K doesn't reach when loading containers, we use arraylist $S_1$ to store partial stacks without rehandles occuring, arraylist $S_2$ to store partial stacks with rehandles occuring, arraylist $S_3$ to store empty stacks.
%The priority order of them is $S_1$, $S_2$, $S_3$.
%If there isn't an overstowage allowed when loading containers, we use $S_0$ to store the feasible stacks, including the partial stacks without rehandles occuring and the empty stacks.
%For ease of illustration, we need to explain the definition of nearport.
%For example, three containers are stored in the same stack, and their destination ports are 4,5,6, respectively, then the value of nearport of this stack is 4.
%If a stack is empty, its nearport will be set to $P+1$, here $P$ is the total number of the ports along the voyage.
%As for other notations, we can find their meanings in this table when we need to know them.

%\begin{table}[!htbp]
%\scriptsize
%  \centering
%  \setlength{\belowcaptionskip}{10pt}
%  \caption{constants, sets, variables and methods in the algorithm}
%    \begin{tabular}{r|l}
%    \hline
%     %$K$, $P$ ,$N$ , $H$ & the meanings of these constants are the same as what described in the above\\
%    % $LB$ & the lower bound for each given instance\\
%    % $UB$ & the upper bound for each given instance\\
%     $P$ & the number of total ports\\
%     $N$ & the number of total containers to be transported\\
%     $H$ & the limited height of stacks in the vessel\\
%     $K$ & the number of allowed rehandles\\
%     $k$  & a variable to record how many rehandles have been used\\
%     $S_0$ & stack index set to store feasible stacks when there isn't an rehandle allowed\\
%     $S_1$ & stack index set to store partial stacks without rehandles when $K$ doesn't reach\\
%     $S_2$ & stack index set to store partial stacks with rehandles when $K$ doesn't reach\\
%     $S_3$ & stack index set to store empty stacks when $K$ doesn't reach\\
%     $height$ & a one-dimension array, represents the current height of each stack\\
%%     $Layout$ & a two-dimension array, represents the layout of containers in vessel after each operation\\
%     $Numofstack$ & the cumulative number of used stacks\\
%     $nearport$ & a one-dimension array to store the nearest port in all containers for each stack\\
%     %$lb$  & a one-dimension array, represents the lower bound of used stacks in each port\\
%%     $ub$ & a one-dimension array, represents the upper bound of used stacks in each port\\
%     $ac$ & an arraylist to ordinally store the information of each container including the origin port and the destination port\\
%     %$Solution$ & an arraylist to ordinally store the operation of each container\\
%     $Container$ & a Class to record the information of each container\\
%     %$Operation$ & a Class to record the information of each operation, including loading, unloading and rehandling\\
%     $heuristic()$ & the main method to complete the container stowage planning along the voyage\\
%     %$read()$ &  a method to read the parameters and the detailed containership information from each instance\\
%%     $bound()$ & a method to provide a lower bound and upper bound and can be used to prove our algorithm's rationality\\
%   \end{tabular}
%   \label{tab:1}
%\end{table}


\subsection{Heuristic algorithm for the SSMP}
\label{sec:h1}
Algorithm \ref{alg:1} solves instances of SSMP.
The main two steps in our heuristic algorithm are unloading and loading procedures.
Given an instance I, for each port $p$ along the voyage, containers with $D(c)==p$ are discharged one by one firstly.
Especially, if there exist blocking containers, they are moved on the yard temporally.
After containers with $D(c)==p$ are discharged, containers on yard (including containers with $O(c)==p$ and blocking containers) are sorted in order and loaded.
The value of $NumofStack$ will be updated when all the containers are processed at port $p$.
$NumofStack$ here are referred as the largest number of used stacks after the containership departs from port $p$.
The algorithm finally outputs the value of $NumofStack$ at port $P$ when all containers in an instance are processed.

\begin{algorithm}[!htbp]
  \caption{A heuristic procedure for the SSMP}
  \label{alg:1}
  \begin{codebox}
  \Procname{\proc{Heuristic(I)}}

    \li \For each port $p=1, 2 , \ldots,P $
    \li \Do
                Unload containers with $D(c)==p$.
    \li         Sort containers with $O(c)==p$ by the decreasing order of their destinations.
    \li         \For each container $c$ with $O(c)==p$ at port $p$
    \li         \Do
                   \If $k==K$
    \li            \Then
                        execute method $loading\_equalK(c,nearport)$.
    \li            \Else If $k < K$
    \li                 execute method $loading\_lessK(c,nearport)$.
                   \End
                \End
    \li          Update the value of $NumofStack$ at port $p$.
        \End
    \li Output the value of $NumofStack$ in instance I.

 \end{codebox}
 \end{algorithm}

When discharging containers at each port, we just need to unload containers from top to bottom one by one when $D(c)==p$ if there isn't a rehandle in the stacks.
when rehandles happen, we have to move the blocking containers on the yard temporally before unloading those target containers.
We will reset their origin ports as current port for the blocking containers on the yard and their destination ports remain unchanged.
That's to say, the outbound containers at the current port increase, containers with $O(c)==p$ and blocking containers are all to be sorted.

The key point in our algorithm is how to load container into the optimal stack to make sure we can minimize the needed stacks.


When loading containers at each port, we adopt two different methods to choose stack for the target containers according to whether the number of real rehandles $k$
and the number of allowed rehandles $K$ are equal.
They are $loading\_equalK(c,nearport)$ and $loading\_lessK(c,nearport)$, respectively.


We firstly talk about the simple condition that the allowed rehandles run out ($k==K$) and the procedure of method $loading\_equalK(c,nearport)$ is given in Algorithm \ref{alg:2}.
We add non-full stacks whose nearest port is no smaller than the current loading container into arraylist $S_0$ when traversing all the stacks to choose the feasible stacks for each container.
For all the stacks in $S_0$, we choose the one with the smallest value of nearport.
If there isn't only one stack with the smallest value of nearport, we choose the first one we traverse.

%\begin{itemize}
%\label{item:1}
%\item[-] $S_0$=currently non-full stacks whose nearport is greater than or equal to $D(c)$.
%\item[-] \If $S_0 \neq \emptyset$, then $s_{min}=\arg\min \limits_{s\in S_0} nearport[s]$.
%\item[-] Clear the arraylist $S_0$
%\item[-] Load container $c$ to stack $s_{min}$
%\item[-] Update the value of nearport of stack $s_{min}$.
%\item[-] Update the height of stack $s_{min}$.
%\end{itemize}


%\begin{enumerate}[step 1]
%\item $S_0$=currently non-full stacks whose nearport is greater than or equal to $D(c)$.
%\item If $S_0 \neq \emptyset$, then $s_{min}=\arg\min \limits_{s\in S_0} nearport[s]$.
%\item Clear the arraylist $S_0$.
%\item Load container $c$ to stack $s_{min}$.
%\item Update the value of nearport of stack $s_{min}$.
%\item Update the height of stack $s_{min}$.
%\end{enumerate}

\begin{algorithm}[!htbp]
    \caption{The procedure for the method $loading\_equalK(c,nearport)$}
    \label{alg:2}
    \begin{codebox}
    \Procname{\proc{$loading\_equalK(c,nearport)$}}
        \li $S_0$=currently non-full stacks whose nearport is greater than or equal to $D(c)$.
        \li \If $S_0 \neq \emptyset$
        \li \Then
                 $s_{min}=\arg\min \limits_{s\in S_0} nearport[s]$.
        \li      Clear the arraylist $S_0$.
        \li      Load container $c$ to stack $s_{min}$.
            \End
        \li Update the value of nearport of stack $s_{min}$.
        \li Update the height of stack $s_{min}$.

       \end{codebox}
\end{algorithm}

Afterwards, we talk about the complex condition that the rehandles are allowed ($k<K$) and the procedure of method $loading\_lessK(c,nearport)$ is given in Algorithm \ref{alg:3}.
Undoubtedly, its procedure to load containers is not as easy as the simple condition.
Under this condition, we use arraylist $S_1$ to store partial stacks without rehandles occuring, arraylist $S_2$ to store partial stacks with rehandles occuring, arraylist $S_3$ to store empty stacks.
The priority order of them is $S_1$, $S_2$, $S_3$, which means the chosen sequence of different types of stacks is stacks without rehandles occuring, stacks with rehandles occuring and empty stacks.
Like the above Algorithm \ref{alg:2}, we choose the first one with the smallest value of nearport when we traverse each set of feasible stacks.

It's worth mentioning that $s_{min}$ in Algorithm \ref{alg:2} and \ref{alg:3} represents the first stack with the smallest value of nearport according to the traversing sequence.

% $S_1$ have the highest priority.
%If $S_1$ is null, we choose the stack from arraylist $S_2$ which is used to store partial stacks whose value of nearport is smaller than the current loading container.
%Both in $S_1$ and $S_2$, we choose the stack whose value of nearport is smallest.
%If there isn't only one stack with the smallest value of nearport, we choose the first one we traverse, which is indexed by $s_{min}$.
%If $S_2$ is null, we choose the first stack when we traverse the $S_3$, which is used to store empty stacks.


%\begin{itemize}
%\label{item:1}
%\item[-] $S_1$=currently partial stacks whose nearport is greater than or equal to $D(c)$.
%\item[-] $S_2$=currently partial stacks whose nearport is smaller than $D(c)$.
%\item[-] $S_3$=currently empty stacks.
%\item[-] If $S_1\neq \emptyset$
%\item[-] Then $s_{min}=\arg\min \limits_{s\in S_1} nearport[s]$
%\item[-] Clear the arraylist $S_1$
%\item[-] Load container $c$ to stack $s_{min}$.
%\item[-] Else If $S_2\neq \emptyset$
%\item[-] Then $s_{min}=\arg\min \limits_{s\in S_2} nearport[s]$
%\item[-] Clear the arraylist $S_2$
%\item[-] Update the value of $k$
%\item[-] Load container $c$ to stack $s_{min}$.
%\item[-] Else Clear the arraylist $S_3$
%\item[-] Load container $c$ to the first empty stack in $S_3$, which is also indexed by $s_{min}$.
%\item[-] Update the value of nearport of stack $s_{min}$.
%\item[-] Update the height of stack $s_{min}$.
%\end{itemize}

%\begin{enumerate}[step 1]
%\item $S_1$=currently partial stacks whose nearport is greater than or equal to $D(c)$.
%\item $S_2$=currently partial stacks whose nearport is smaller than $D(c)$.
%\item $S_3$=currently empty stacks.
%\item If $S_1\neq \emptyset$, then $s_{min}=\arg\min \limits_{s\in S_1} nearport[s]$.
%\item Clear the arraylist $S_2$.
%\item Update the value of $k$.
%\item Load container $c$ to stack $s_{min}$.
%\item Else Clear the arraylist $S_3$.
%\item Load container $c$ to the first empty stack in $S_3$, which is also indexed by $s_{min}$.
%\item Update the value of nearport of stack $s_{min}$.
%\item Update the height of stack $s_{min}$.
%\end{enumerate}

\begin{algorithm}[!htbp]
    \caption{The procedure for the method $loading\_lessK(c,nearport)$}
    \label{alg:3}
    \begin{codebox}
    \Procname{\proc{$loading\_lessK(c,nearport)$}}
        \li $S_1$=currently partial stacks whose nearport is greater than or equal to $D(c)$.
        \li $S_2$=currently partial stacks whose nearport is smaller than $D(c)$.
        \li $S_3$=currently empty stacks.
        \li \If $S_1\neq \emptyset$
        \li \Then
                        $s_{min}=\arg\min \limits_{s\in S_1} nearport[s]$.
        \li             Clear the arraylist $S_1$.
        \li             Load container $c$ to stack $s_{min}$.
        \li    \Else If $S_2\neq \emptyset$
                        \Then
        \li               $s_{min}=\arg\min \limits_{s\in S_2} nearport[s]$.
        \li               Clear the arraylist $S_2$.
        \li               Update the value of $k$.
        \li               Load container $c$ to stack $s_{min}$.
        \li         \Else
        \li               Clear the arraylist $S_3$.
        \li               Load container $c$ to the first empty stack in $S_3$, which is also indexed by $s_{min}$.
                    \End
             \End
        \li Update the value of nearport of stack $s_{min}$.
        \li Update the height of stack $s_{min}$.
\end{codebox}
\end{algorithm}

From Algorithm \ref{alg:2} and \ref{alg:3}, we can see that we will clear the arraylist once we have chosen the stack for the target container.
Of course, we will undate the value of $k$ if there is a rehandle when loading containers.
After loading the target container into the chosen stack, the value of nearport and height of this stack need to be updated.


In a word, a lot of variables and methods of the concrete unloading and loading strategies have been involved, we don't give the complete pseudo here for the sake of context length.
For example, the method to record the loading and unloading information isn't given in this paper.
As is explained in the heading of this section, we divide the loading strategy into two methods on the basis of the number of allowed rehandles.
What is identical for the two methods is that they choose the optimal stack for each container during the loading process according to the greedy rules made by our algorithm.
Similarly, the unloading strategy are divided into two conditions depending on whether there are rehandles.
As a result, specific steps are a little different from each other between the two circumstances.

Our algorithm can give the detailed location changes of each container and output the layout status in the vessel at arbitrary time.
In other words, we can predict the real-time container stowage process before the voyage as long as we know some information in advance.
Therefore, our algorithm makes a little difference and makes some sense in the reality application.


\subsection{Performance Guarantee of the Algorithms}
\label{sec:p2}

In order to simplify the problem, we show that the heuristic algorithms have a performance guarantee and we regard the port number $P$ as a fixed number in our voyage.
For ease of exposition, we first give some related notations.

\begin{itemize}
\item $\mathcal{C}^*$: the optimal solution to the SSMP instances.
\item $\mathcal{C}$: the solution to the SSMP instances by the algorithm.
\item $N_p$: the number of containers on the ship before its departure from port $p$.
\item $V_p$: the number of loading ports that the ship has visited before it departs from port $p$.
\end{itemize}

It should be noted that a port is called a loading port if there exists at least one container to be loaded. Clearly, $V_p \le p$, $\forall p=1,\ldots,P$.

\begin{proposition}
The SSMP instance has a lower bound:
\begin{equation*}
\max\limits_{p=1,\ldots,P}(\lceil\frac{N_p}{H}\rceil) \le \mathcal C^*
\end{equation*}
\label{pro:a1}
\end{proposition}

\begin{proof}

$\lceil\frac{N_p}{H}\rceil$ is the least number of stacks to accommodate all the containers at port $p$, and thus, $\max\limits_p(\lceil\frac{N_p}{H}\rceil)$ is the least number of stacks needed throughout the journey.
\end{proof}

The lower bound can be a reference to check the optimality of solutions obtained by our heuristic.
If the solution is close to the lower bound, we can conclude that the solution is close to optimal.

We divide the stack used in the port into two parts: full stacks and partial stacks.
For the full stacks, the number of full stacks in port $p$ is no greater than $\lfloor\frac{N_p}{H}\rfloor$.
For the partial stacks, we define the number of partial stacks in port $p$ as $P(p)$, and we get  Proposition \ref{pro:a3} for $P(p)$.
\begin{proposition}
The number of partial stacks in port $p$ is no greater than $V_p$:
\begin{equation*}
 P(p) \le  V_p
\end{equation*}
\label{pro:a3}
\end{proposition}

\begin{proof}

We use an inductive proof.

\textit{Basis}: For $p=1$, without loss of generality, we assume that port 1 is a loading port, and therefore $V(p=1)$ =1.
In addition, P(1)=0 or 1, i.e. $P(1) \le 1$. Hence, $P(p) \le V_p $ holds.
For $p=2$, there isn't any blocking containers when discharging the containers from the ship, $P(2) \le 1$ still holds.
If there are containers to be loaded at port 2, then $V(p=2)$ =2, $P(2)$ will add one at most whether there will be rehandles or not.
That's to say, $P(2) \le V(p=2)$.
If no containers is loaded at port 2, then $V(p=2)$ =1, $P(2) \le 1=V(p=2)$ still holds.

\textit{Inductive step}: Suppose that the partial stacks in port $p$ is no greater than $V_p$.
Upon the ship arrives at port $p+1$, it first unloads the containers from the ship.
This process does not increase the number of partial stacks comparing with the former port whether there are blocking containers or not.

(1)If there are containers to be loaded at port $p+1$, then $V_{p+1}=V_p+1$,  $P($p+1$) \le P(p)+1$ whether we allow the rehandle or not in port $p+1$. %Hence, $P($p+1$) \le P(p)+1 \LE V_{p+1}= V_p+1$.

(2)If there is no containers to be loaded at port $p+1$,  $V_{p+1}=V_p$, $P($p+1$) \le P(p)$. Hence, $P($p+1$) \le P(p) \le V_{p}=V_{p+1}$.

Based on the above two steps, we have $P(p) \le V_p,  \forall p=1,\ldots,P$.
\end{proof}


\begin{proposition}
For the heuristic solution to the SSMP instance, it holds
\begin{equation*}
\mathcal{C}^* \le \mathcal{C} \le \max_{p=1,\ldots,P}(\lfloor\frac{N_p}{H}\rfloor+V_p) \le \mathcal{C}^*+V_P
\end{equation*}
\label{pro:a2}
\end{proposition}

\begin{proof}

The first inequality obviously holds.

For the second inequality, $\mathcal{C}=\max\limits_p \mathcal{C}_p$.
Noted that $\mathcal{C}_p$ is the number of used stacks in port $p$ obtained from our algorithm and it includes the number of full stacks and the number of partial stacks.
As the number of full stacks in port $p$ is no greater than $\lfloor\frac{N_p}{H}\rfloor$ and the number of partial stacks in port $p$ is no greater than $V_p$.
Therefore, the second inequality holds.
For the third inequality, $\lfloor\frac{N_p}{H}\rfloor\leq \lceil\frac{N_p}{H}\rceil$, and $\lceil\frac{N_p}{H}\rceil$ is the lower bound of the number of stacks used at port $p$ by Proposition \ref{pro:a1}.
Thus, $\lfloor\frac{N_p}{H}\rfloor \le \mathcal{C}_p^*$.
It then holds $\max\limits_p(\lfloor\frac{N_p}{H}\rfloor+V_p) \le \max\limits_p(\mathcal{C}^*+V_p) = \mathcal{C}^*+V_P$.
\end{proof}


The above propositions show that our heuristic algorithm has a constant performance guarantee.
In the real shipping transportation, the number of ports is generally much smaller than the number of used stacks.
Therefore, the difference between the optimal solution and our heuristic solution is relatively small, which indicates that our heuristic algorithms can generate promising solutions.

Due to page limit, we omit the details here. Interested readers are welcome to contact the authors for details.
% In view of the number of allowed rehandle we give isn't big and it's influence on the result isn't salient. So we use the $UB$ to test the effectiveness of SSMP-KR.




\section{Experiments and Analysis}
\label{sec:ea}

This paper uses the test data from the existing literature (\cite{wang2014stowage}) and we add an extra parameters $K$ into the primary instances in order to meet the demands of research.
$K$ means the number of allowed rehandles and it is selected from \{0, 10, 20, 50, 100\}.
Particular, instances with $K=0$ represent the benchmark instances comparing with the same instances with different values of $K$.
In fact, the problem becomes SSMP-ZR when $K=0$.
There are 360 sets of instances, or 1800 instances in total, which are categorized by three parameters: the number of ports $P$, which is selected from \{5, 10, 20, 30\};
the number of containers $N$, which is selected from \{50, 100, 200, 500, 1000, 5000\};
and the height limit $H$ is selected from \{4, 8, 12\}.
Each set consists of 5 instances generated by different random seeds.
In each instance, the origin $O(i)$ and the destination $D(i)$ of a container $i$ are generated from a uniform distribution on the integers $1, 2, \ldots, P$ satisfying that $O(i)<D(i)$.
For the convenience of comparison, we only show the average value of "Numofstack" when $K=0$, $K=10$, $K=20$, $K=50$, $K=100$, respectively.
%What's more, this is applicable to the heuristic algorithm as well as the deuterogenic $P\&H$ algorithm, which will be introduced in the next content.

In this section, we will showcase the performance of our heuristic algorithms on a number of test instances.
The heuristic was implemented in Java and the experiments were conducted on a computer with Intel Core processor clocked at 2.30 GHz and 8 GB RAM.
The operating system of the computer is Windows 10.

The experimental results are shown in Table \ref{tab:2} and Table \ref{tab:3}.
Considering the size of table, the results of instances with 5000 containers are not listed.

\begin{table}[!htbp]
\small
  \centering
  \setlength{\belowcaptionskip}{10pt}
  \caption{Results of the instances with $P\in\{5, 10\}$}
  \begin{tabular}{ccccccccccccccc}
  \hline
  \multicolumn{1}{c}{\multirow{2}{*}{P}}
  & \multicolumn{1}{c}{\multirow{2}{*}{N}}
  & \multicolumn{1}{c}{\multirow{2}{*}{H}}
  & \multicolumn{7}{c}{Heu}
  & \multicolumn{5}{c}{Ran}\\
  \cline{4-15}
  \multicolumn{1}{c}{}
  &\multicolumn{1}{c}{}
  &\multicolumn{1}{c}{}
  &\multicolumn{1}{c}{LB}&{UB}&{K=0}&{K=10}&{K=20}&{K=50}&{K=100}
  &\multicolumn{1}{c}{K=0}&{K=10}&{K=20}&{K=50}&{K=100}\\
  \hline

    5     & 50    & 4     & 8     & 9.6   & 8     & 8     & 8     & 8     & 8     & 12.2  & 9.6   & 10.4  & 9.6   & 9.6 \\
    5     & 50    & 8     & 4     & 6     & 4.6   & 4     & 4     & 4     & 4     & 10    & 8.4   & 8     & 9.6   & 7.8 \\
    5     & 50    & 12    & 3     & 5     & 3.2   & 3.2   & 3     & 3     & 3     & 9.2   & 9.2   & 7     & 8.6   & 7.6 \\
    5     & 100   & 4     & 15    & 16.8  & 15    & 15    & 15    & 15    & 15    & 18.4  & 16.2  & 16.2  & 16.6  & 16.6 \\
    5     & 100   & 8     & 7.6   & 9.6   & 7.6   & 7.6   & 7.6   & 7.6   & 7.6   & 14.2  & 14.8  & 12.8  & 12    & 13.2 \\
    5     & 100   & 12    & 5.4   & 7.6   & 5.4   & 5.6   & 5.4   & 5.4   & 5.4   & 14.2  & 14.4  & 12.6  & 13.2  & 12 \\
    5     & 200   & 4     & 30.6  & 32.2  & 30.6  & 30.6  & 30.6  & 30.6  & 30.6  & 32.8  & 32.4  & 32.4  & 32    & 33 \\
    5     & 200   & 8     & 15.6  & 17.4  & 15.6  & 15.6  & 15.6  & 15.6  & 15.6  & 23.6  & 24.6  & 22.4  & 19.4  & 20.4 \\
    5     & 200   & 12    & 10.4  & 12.4  & 10.4  & 10.4  & 10.4  & 10.4  & 10.4  & 21.8  & 22.8  & 20.4  & 19.2  & 16.2 \\
    5     & 500   & 4     & 76.6  & 78    & 76.6  & 76.6  & 76.6  & 76.6  & 76.6  & 78.6  & 78.6  & 78    & 77.8  & 79 \\
    5     & 500   & 8     & 38.6  & 40    & 38.6  & 38.6  & 38.6  & 38.6  & 38.6  & 46    & 44.4  & 45    & 42.8  & 42 \\
    5     & 500   & 12    & 26    & 27.4  & 26    & 26    & 26    & 26    & 26    & 38    & 36.2  & 39.8  & 37.6  & 33.8 \\
    5     & 1000  & 4     & 152.2 & 153.8 & 152.2 & 152.2 & 152.2 & 152.2 & 152.2 & 153.6 & 153.6 & 154.2 & 154.2 & 153.4 \\
    5     & 1000  & 8     & 76.6  & 78.2  & 76.6  & 76.6  & 76.6  & 76.6  & 76.6  & 82.2  & 81.8  & 81.4  & 80.2  & 79.6 \\
    5     & 1000  & 12    & 51    & 52.8  & 51    & 51    & 51    & 51    & 51    & 61.4  & 60.8  & 60.4  & 63    & 60.4 \\
    10    & 50    & 4     & 7.8   & 12.6  & 9     & 8     & 7.8   & 7.8   & 7.8   & 12.4  & 11    & 10.2  & 9.8   & 9.6 \\
    10    & 50    & 8     & 4     & 10    & 6     & 6     & 5     & 4     & 4     & 10.8  & 10.8  & 10.4  & 8.8   & 8.8 \\
    10    & 50    & 12    & 3     & 9.4   & 5.6   & 4.6   & 4.4   & 3.2   & 3     & 12    & 11.4  & 9     & 8.8   & 8.6 \\
    10    & 100   & 4     & 14.8  & 19.6  & 15.8  & 15.6  & 15    & 14.8  & 14.8  & 20.4  & 20.2  & 20.2  & 16.8  & 17.4 \\
    10    & 100   & 8     & 7.6   & 12.6  & 9.2   & 9.8   & 9.6   & 7.8   & 7.6   & 20    & 18.4  & 17    & 13.6  & 13.6 \\
    10    & 100   & 12    & 5.2   & 10.4  & 7     & 7     & 7.2   & 6.4   & 5.2   & 18.4  & 17.8  & 17.6  & 13.8  & 14.2 \\
    10    & 200   & 4     & 28.6  & 33.2  & 29.6  & 29.6  & 28.6  & 28.6  & 28.6  & 35.4  & 36    & 34.4  & 31.4  & 30.6 \\
    10    & 200   & 8     & 14.4  & 19.2  & 16.4  & 16.6  & 16.2  & 14.8  & 14.4  & 28.6  & 29.2  & 25.6  & 27.4  & 23 \\
    10    & 200   & 12    & 9.8   & 15    & 12    & 12    & 11.8  & 11.4  & 9.8   & 26.4  & 27.2  & 26.8  & 24.2  & 24 \\
    10    & 500   & 4     & 69.8  & 74.2  & 69.8  & 69.8  & 69.8  & 69.8  & 69.8  & 78    & 75.4  & 74.6  & 74.2  & 71.2 \\
    10    & 500   & 8     & 35    & 39.4  & 35.6  & 35    & 35.2  & 35    & 35    & 52.8  & 49.4  & 52.6  & 51.4  & 52.6 \\
    10    & 500   & 12    & 23.6  & 28    & 25.2  & 24.8  & 24.8  & 24    & 23.6  & 50.2  & 48.4  & 50    & 47.4  & 47.6 \\
    10    & 1000  & 4     & 137.6 & 141.8 & 137.6 & 137.6 & 137.6 & 137.6 & 137.6 & 143.2 & 143.8 & 143.4 & 141.8 & 140.2 \\
    10    & 1000  & 8     & 69    & 73.2  & 69.2  & 69    & 69.2  & 69    & 69    & 87.8  & 84.8  & 85.8  & 86    & 85.2 \\
    10    & 1000  & 12    & 46.2  & 50.4  & 46.6  & 46.8  & 46.8  & 46.6  & 46.2  & 77.2  & 78    & 74.4  & 76.4  & 74.8 \\

    \hline
    \end{tabular}
  \label{tab:2}
\end{table}


\begin{table}[!htbp]
\small
  \centering
  \setlength{\belowcaptionskip}{10pt}
  \caption{Results of the instances with $P\in\{20, 30\}$}
  \begin{tabular}{ccccccccccccccc}
  \hline
  \multicolumn{1}{c}{\multirow{2}{*}{P}}
  & \multicolumn{1}{c}{\multirow{2}{*}{N}}
  & \multicolumn{1}{c}{\multirow{2}{*}{H}}
  & \multicolumn{7}{c}{Heu}
  & \multicolumn{5}{c}{Ran}\\
  \cline{4-15}
  \multicolumn{1}{c}{}
  &\multicolumn{1}{c}{}
  &\multicolumn{1}{c}{}
  &\multicolumn{1}{c}{LB}&{UB}&{K=0}&{K=10}&{K=20}&{K=50}&{K=100}
  &\multicolumn{1}{c}{K=0}&{K=10}&{K=20}&{K=50}&{K=100}\\
  \hline

    20    & 50    & 4     & 7.2   & 19.6  & 9     & 9     & 8     & 7.2   & 7.2   & 13    & 12.2  & 10.8  & 10.2  & 9.6 \\
    20    & 50    & 8     & 3.8   & 19    & 7.8   & 7     & 6.6   & 5.4   & 3.8   & 12.8  & 13    & 10.8  & 8.8   & 8.8 \\
    20    & 50    & 12    & 2.8   & 19    & 7.8   & 6.6   & 5.6   & 4     & 2.8   & 13.6  & 12.4  & 11    & 8     & 8 \\
    20    & 100   & 4     & 14.2  & 25    & 16    & 16    & 16    & 14.2  & 14.2  & 21    & 21.8  & 22.2  & 17.8  & 16 \\
    20    & 100   & 8     & 7.4   & 19.6  & 10.8  & 11    & 10.8  & 10.2  & 7.6   & 20.6  & 19.4  & 19.4  & 17.4  & 13.4 \\
    20    & 100   & 12    & 5     & 19.2  & 10.2  & 9.8   & 9     & 9     & 7.6   & 21.2  & 21.4  & 20    & 18.4  & 13 \\
    20    & 200   & 4     & 27.6  & 37.6  & 29.8  & 30.2  & 29.8  & 28.8  & 27.6  & 39.6  & 37    & 37.2  & 36.4  & 31.8 \\
    20    & 200   & 8     & 14.2  & 25.2  & 17.6  & 18    & 18    & 17.4  & 17.4  & 33.4  & 35.4  & 32    & 31.8  & 28.6 \\
    20    & 200   & 12    & 9.4   & 21.6  & 13.8  & 13    & 13.8  & 13.2  & 13.4  & 33.8  & 31.6  & 31.8  & 30.2  & 30.8 \\
    20    & 500   & 4     & 67.6  & 77.2  & 70.2  & 70.4  & 70    & 70.4  & 67.6  & 80    & 81    & 80.8  & 80.4  & 77.8 \\
    20    & 500   & 8     & 34    & 43.6  & 38    & 37.6  & 37.8  & 38    & 38    & 64.2  & 64.6  & 62.6  & 61.4  & 61 \\
    20    & 500   & 12    & 22.8  & 33.2  & 27    & 27.2  & 27.2  & 27.2  & 27.2  & 60.8  & 61.6  & 62.4  & 59.8  & 58 \\
    20    & 1000  & 4     & 134.4 & 143.6 & 135.8 & 135.8 & 136.2 & 136   & 134.4 & 148   & 146   & 148.6 & 148.4 & 147.4 \\
    20    & 1000  & 8     & 67.6  & 76.8  & 70.6  & 71    & 70.4  & 70.4  & 70.6  & 102.2 & 101.6 & 101   & 100.2 & 100.8 \\
    20    & 1000  & 12    & 45.2  & 54.4  & 48.8  & 49.8  & 49.2  & 49.2  & 48.8  & 93.8  & 97.4  & 97.4  & 94.8  & 91.6 \\
    30    & 50    & 4     & 8     & 29.8  & 10    & 9.8   & 9.4   & 8     & 8     & 15.8  & 13.4  & 11    & 10.6  & 10.6 \\
    30    & 50    & 8     & 4.2   & 29    & 8.2   & 7.8   & 7.6   & 5.2   & 4.2   & 15.8  & 13.2  & 11.6  & 10    & 9.6 \\
    30    & 50    & 12    & 3     & 29    & 8     & 7.4   & 6.8   & 5.2   & 3.4   & 14.6  & 14.4  & 12.8  & 9     & 8.8 \\
    30    & 100   & 4     & 13.8  & 33.4  & 16.8  & 16.6  & 16.2  & 15.6  & 13.8  & 22.4  & 22.8  & 22.8  & 19.6  & 16.6 \\
    30    & 100   & 8     & 7.2   & 29.6  & 12    & 11.4  & 11.8  & 10.8  & 9.8   & 22    & 21.8  & 20.8  & 19    & 15 \\
    30    & 100   & 12    & 5     & 29    & 10.8  & 10.4  & 10.2  & 9.8   & 8.2   & 21.8  & 21.8  & 20.4  & 19.8  & 15.2 \\
    30    & 200   & 4     & 27.6  & 43.8  & 30.4  & 31    & 31.6  & 31.2  & 28    & 40.6  & 39.8  & 41.2  & 38.6  & 34 \\
    30    & 200   & 8     & 14    & 32.2  & 18.6  & 18.8  & 19    & 19.4  & 19.8  & 36.4  & 36.2  & 36.2  & 36.8  & 32.8 \\
    30    & 200   & 12    & 9.6   & 29.8  & 17    & 16.6  & 16.2  & 16.2  & 16.2  & 35.6  & 36    & 37    & 34.8  & 33.4 \\
    30    & 500   & 4     & 64.8  & 80.4  & 69.6  & 69.6  & 69.6  & 69.4  & 69.2  & 83.2  & 82.2  & 82.8  & 82    & 81.8 \\
    30    & 500   & 8     & 32.6  & 49    & 38.4  & 38.6  & 38.6  & 38.2  & 37.8  & 68.8  & 66    & 68.6  & 70.6  & 66.4 \\
    30    & 500   & 12    & 22.2  & 39.2  & 29    & 29    & 28.6  & 28.6  & 28.8  & 69.2  & 67.4  & 66.2  & 66.6  & 66 \\
    30    & 1000  & 4     & 128.8 & 144   & 133.6 & 133.6 & 133.6 & 133.8 & 133.6 & 149   & 150.8 & 150   & 147.8 & 150.6 \\
    30    & 1000  & 8     & 64.8  & 80.4  & 71.4  & 70.6  & 71    & 70.6  & 70.6  & 111.2 & 112.8 & 111.8 & 110.6 & 110 \\
    30    & 1000  & 12    & 43.2  & 59.4  & 50.8  & 50.6  & 50.8  & 50.8  & 50.8  & 107.6 & 108.8 & 108.6 & 107   & 101.2 \\

    \hline
    \end{tabular}
  \label{tab:3}
\end{table}

Table \ref{tab:2} summarizes the results of those easy instances with small number of ports, i.e. $P \in \{5, 10\}$.
For each given $P$, $N$ and $H$, we work out the value of $LB$, $UB$ of our heuristic algorithm and and the average numbers of $Numofstack$ of our heuristic algorithm and random algorithm in different instances when $K$ selects different values.
The $LB$ and $UB$ are used to test the rationality of heuristic algorithm and the average $Numofstack$ of instances with different values of $K$ by using heuristic and random algorithms are used to compare with each other.

Table \ref{tab:3} summarizes that the results of those difficult instances with large number of ports, i.e. $P \in \{20, 30\}$.
The columns in this table are similarly defined as those of Table 1 and so is the conclusion we can get from Table 1.

Most of instances provide the evidence that it works better when $K$ isn't equal to zero comparing the condition where $K$ is equal to zero.
However, the results between the easy instances and difficult instances have some differences.
Comparing with the significant influence of different $K$ in the difficult instances, the influence of different $K$ in the easy instances isn't obvious.
The same conclusion can be drawn if we focus on one specific variable or factor while keeping other variables unchanged.

As far as we are concerned, we think it is the density and sparseness of stacks that cause this consequence.
In other words, the smaller value of each variable is, the same kind of containers that have the identical origin port and destination port have more chance to be placed in the same stack and less rehandles will arise.
We call this kind of stack with high density, and the high sparseness in contrast.

For the instance with the same $P$, $N$ and $H$, we call it benchmark instance when $K$ is equal to zero.
If the number of used stacks is larger than the benchmark instance when $K$ isn't equal to zero, we call it an exceptional instance.
There are few exceptions when we analyze the result through a large amount of experiments.
Comparing with the zero rehandles, the number of needed stack is even larger when the allowed rehandle $K$ isn't equal to zero, though the deviation is not great.

We then find out those exceptional instances and compare the stowage planning with the same instances under the zero rehandle constraint, and we think it's the distribution status of previous containers to be blamed.
The allowed rehandles delay the production of new stacks but not to reduce them, that's why the problem happens.
Actually, it's the unloading strategy for blocking containers that causes this exceptional condition.
Because we reset the origin port of blocking containers, the loading containers in current port increases and meanwhile the allowed rehandles run out.
In the end, the new stacks are needed under the coincidence.
In order to prove it, we output the layout of the exceptional instances and the corresponding benchmark instances.
By comparing the exceptional instances with the corresponding benchmark instances, we get the conclusion that both the distribution of containers and the algorithm are blamed for this kind of abnormal condition.
In our heuristic algorithm, we reset the blocking containers' origin ports as the current port, and it enlarges the number of containers to be loaded.
Meanwhile, the allowed rehandles run out and thus new stacks are needed to stow those new outbound containers.

However, it doesn't mean that our algorithm isn't universal because the probability of causing exceptional instances is very low and it hardly happens in our practical operations.
Therefore, our heuristics algorithm is feasible for most of the instances and has a good performance as well.
The following tables and figures can be used to illustrate the good performance of our algorithm.

We then analyze the average result of all instances to get some conclusions.
Table \ref{tab:4} and Figure \ref{fig 2:graph} give the average results of heuristic and random algorithm when the allowed rehandle $K$ has different values.
It's not difficult to draw the conclusion that the number of used stacks gets smaller as the allowed rehandle becomes larger for both heuristic algorithm and random algorithm.
Another conclusion is, comparing with random algorithm, our heuristic algorithm has a fairly good performance to work out the solution to the SSMP.
It's noteworthy that the average results in Table \ref{tab:4} include the instances with $N=5000$.

\begin{table}[!htbp]
  \centering
  \setlength{\belowcaptionskip}{10pt}
  \caption{average results of the instances with different K for two algorithms}
    \begin{tabular}{r|r|r|r|r|r}
    \hline
     $K$       &0   &10  &20  &50  &100\\
    \hline
    $Numofstack$ of Heu   &99.3  &99.21944  &99.08333   &98.73889  &98.35\\
 \hline
    $Numofstack$ of Ran  &114.62778  &114.31667  &114.21448  &112.86111 &111.9\\
 \hline
    \end{tabular}
  \label{tab:4}
\end{table}

\begin{figure}[htbp]
\centering
\setlength{\abovecaptionskip}{10pt}
\resizebox{1.0\textwidth}{!}{\includegraphics{figure/result_Heu&Ran.png}}
\caption{Numofstack of Heu and Ran with different K.}
\label{fig 2:graph}
\end{figure}

There is a simple example to elaborate why a certain number of allowed rehandles can improve the utilization of containership comparing with the zero rehandle.
Assuming that there are thirteen containers to be transported along the voyage with six ports.
We let C(i,j) denote index container whose origin port is i and destination port j.
The following is the way to denote those containers: four containers are C(1,3), one is C(2,4), one is C(2,6), four are C(3,5), one is C(4,6) and two are C(5,6).

If they are loaded without any rehandles, the loading sequence and layout will be the following Figure \ref{fig 3:graph}.
\begin{figure}[htbp]
\centering
\setlength{\abovecaptionskip}{10pt}
\resizebox{1.0\textwidth}{!}{\includegraphics{figure/without_rehandle.jpg}}
\caption{stowage plan without rehandle.}
\label{fig 3:graph}
\end{figure}


If they are loaded with rehandles, the loading sequence and layout will be the following Figure \ref{fig 4:graph}.
\begin{figure}[htbp]
\centering
\setlength{\abovecaptionskip}{10pt}
\resizebox{0.9\textwidth}{!}{\includegraphics{figure/with_rehandle.jpg}}
\caption{stowage plan with rehandle.}
\label{fig 4:graph}
\end{figure}


From the above figures, we can draw the conclusion that allowing a certain number of rehandles will reduce the number of stacks used to store containers in a vessel compared with zero rehandle.
That's to say, the utilization of containership can be improved if some rehandles are allowed.

In fact, we have tried a related algorithm named $P\&H$ algorithm before adopting our current heuristic algorithm to get the stowage planning.
This algorithm is actually a process of parameter tuning, our original intention is attempting to find out better solution to stow containers.
Nevertheless, the result through this algorithm isn't as good as the heuristic algorithm and it doesn't work well as we expected if the value of $K$ is small.
From another point of view, it just shows the good performance of our heuristic algorithm.

In our $P\&H$ algorithm, we give some restrictions on the height and the destination port of current loading container when choosing stack for each container.
All the parameters in $P\&H$ value between 0 and 1, the former is not included.
The former parameter represents the ratio of the loading container's destination port and the farthest port $P$.
If their values are equal, the value of parameter is 1.
The latter parameter represents the ratio of stack's height and the limited height $H$.
The main idea of $P\&H$ algorithm is to take the destination port of loading container and the limit height of stack into consideration.
The purpose of this algorithm is to load those containers with farther destination port into the bottom of stack and the computational result will be listed in the Table \ref{tab:5}.

\begin{table}[!htbp]
  \centering
  \setlength{\belowcaptionskip}{10pt}
  \caption{average results of the instances with $P\&H$ algorithm}
    \begin{tabular}{r|r|r|r|r|r}
    \hline
     $P\&H$       &0   &10  &20  &50  &100\\
    \hline
    $0.75\&0.75$   &99.32222  &99.24167  &99.08056   &98.725  &98.29167\\
    \hline
    $0.75\&0.80$   &99.32222  &99.24167  &99.08056   &98.725  &98.29167\\
    \hline
    $0.80\&0.75$   &99.30833  &99.225  &99.05556   &98.71111  &98.31389\\
    \hline
    $0.80\&0.80$    &99.30833  &99.225  &99.05556   &98.71111  &98.31389\\
    %\hline
%    $1.0\&1.0$      &97.68542  &97.61042  &97.4875    &97.15  &96.77708\\
    \hline
    \end{tabular}
  \label{tab:5}
\end{table}

Table \ref{tab:5} shows the result with "P\&H" algorithm, which is firstly designed to improve the original algorithm and eventually it is used to prove the good performance of our original algorithm.
It's noteworthy that the average results in Table \ref{tab:5} include the instances with $N=5000$.
Both the values of two parameters of the algorithm are selected form \{0.75, 0.8\}.
It's clear that the result shows the allowed rehandles will decrease the number of used stacks as the above results in Table \ref{tab:4}.
We can draw a conclusion that the first parameter has a significant influence on the result while the second parameter makes no difference if we compare the result in each line.
I suppose that it happens as a result of the value set of $H$.
Comparing with the results shown in Table \ref{tab:4}, we could find that original algorithm we propose works better when the value of $K$ is small while the "$P\&H$" algorithm gets the similar results when the value of $K$ is large.

To find the relationship between the related parameters and the result of our heuristic.
We use some data from our results obtained from heuristic algorithm to produce the Figure \ref{fig 5:graph} to make it visual.

\begin{figure}[htbp]
\centering
\setlength{\abovecaptionskip}{10pt}
\resizebox{0.9\textwidth}{!}{\includegraphics{figure/comprehensive_analysis.png}}
\caption{comprehensive analysis.}
\label{fig 5:graph}
\end{figure}

%\begin{figure}[htbp]
%\centering
%\setlength{\abovecaptionskip}{10pt}
%\resizebox{0.9\textwidth}{!}{\includegraphics}{figure/comprehensive_analysis.png}
%\caption{comprehensive analysis of result.}
%\label{fig 5:graph}
%\end{figure}

%\begin{figure}[htbp]
%\centering
%\setlength{\abovecaptionskip}{10pt}
%\resizebox{0.9\textwidth}{!}{\includegraphics{figure/comprehensive_analysis.png}}
%\captiond{comprehensive analysis of result.}
%\label{fig 5:graph}
%\end{figure}

Seeing from Figure \ref{fig 5:graph}, we can get the following relationships.
On one hand, the more ports, the more containers and the higher the limit height will result in the more needed stacks if we only change the factor we want to analyze.
On the other hand , the difference in the results between zero rehandle and some allowed rehandles become obvious as the number of port gets larger, the limit height  gets higher and the number of container gets smaller.

In short, the rationality and good performance of our heuristic have been confirmed through the above tables and figures.





%We also use some pictures to make our results more visual and the pictures are made by Excel.
%
%\begin{figure}[htbp]
%\centering
%\setlength{\abovecaptionskip}{10pt}
%\resizebox{0.5\textwidth}{!}{\includegraphics{figure/K-Stacks.png}}
%\caption{Relationship between allowed rehandle and used stacks}
%\label{fig 4:graph}
%\end{figure}
%
%
%As what is shown in Table \ref{tab:4}, Figure \ref{fig 4:graph} indicates visually the relationship between used stacks and allowed rehandle.
%It's not hard to draw the conclusion that the more allowed rehandle, the less used stacks.
%So it intuitively reflects the meaning of this research and it shows the feasibility of our algorithm.
%Comparing with zero rehandle, some rehandles are allowed to reduce the needed stacks and thus improve the utilization of containership.
%
%\begin{figure}[htbp]
%\centering
%\setlength{\abovecaptionskip}{10pt}
%\resizebox{0.5\textwidth}{!}{\includegraphics{figure/K-containers.png}}
%\caption{Relationship between containers and used stacks}
%\label{fig 5:graph}
%\end{figure}
%
%
%Figure \ref{fig 5:graph} shows us the relationship between containers and used stacks.
%We can conclude that the more containers are, the more stacks will be used, which is undoubted in practice.
%Another conclusion can be drawn is that the more containers, the difference caused by rehandles is less.
%
%
%\begin{figure}[htbp]
%\centering
%\setlength{\abovecaptionskip}{10pt}
%\resizebox{0.5\textwidth}{!}{\includegraphics{figure/K-ports.png}}
%\caption{Relationship between ports and used stacks}
%\label{fig 6:graph}
%\end{figure}
%
%Figure \ref{fig 6:graph} provides us the relationship between ports and used stack. In general, the more ports are among the shipping, the more stacks will be used.
%Another related factor to be  taken into consideration is the sparse distribution situation of containers in each port.
%
%\begin{figure}[htbp]
%\centering
%\setlength{\abovecaptionskip}{10pt}
%\resizebox{0.5\textwidth}{!}{\includegraphics{figure/K-limit_height.png}}
%\caption{Relationship between limit height and used stacks}
%\label{fig 7:graph}
%\end{figure}
%
%Figure \ref{fig 7:graph} shows us that the larger the number of limit height is, the less stacks will be used, which is definitely right.
%
%
%\begin{figure}
%\centering
%\setlength{\abovecaptionskip}{10pt}
%\resizebox{0.5\textwidth}{!}{\includegraphics{figure/K-comprehensive.png}}
%\caption{Relationship between comprehensive factors and used stacks}
%\label{fig 8:graph}
%\end{figure}
%
%Figure \ref{fig 8:graph} shows us that the comprehensive impact on the result we work out with all the basic factors considered in this paper.
%Further, we can choose the factors we want to analyze one by one and it is convenient for us to work out how different factors influence our final result.
%For the convenience of observation, we only give the result with filtered choices of each factor.


\section{Conclusion}
\label{sec:con}
The stowage stack minimization problem with K-rehandle constraint (SSMP-KR) is aimed to find out a stowage plan that fewest stacks on a containership are required to accommodate given containers throughout a voyage by subject to K-rehandles.

In this paper, we analyze the structure of this two-dimensional bin-packing optimization problem and its relationship with the SSMP-ZR problem proposed in \cite{wang2014stowage}.

We can regard the stowage stack minimization problem with zero rehandle as an particular case when we choose the value of K as zero.
Hence, the problem proposed in this paper is a generalized and extended problem of SSMP-ZR considering the existence of K-rehandle.

On the one hand, the stowage planning problems in cyclic navigation path is converted into linear navigation path using the specific method.
On the other hand, the result is equivalent to each other whether we convert or not.

In this paper, we presented the integer programming model for the SSMP-ZR and presented a simple IP model for the SSMP-KR.

A heuristic approach is proposed to construct near-optimal solutions to the SSMP-KR problem in a very short computational time.
Since there are different status in the process of handling containers, different methods in our algorithm are thought to cope with the corresponding conditions.

The experimental results show that our heuristic approaches generate very promising solutions on a variety of instances.
Comparing with the stowage stack minimum problem with zero constraint, our problem with K rehandle constraint can offer a certain flexibility for the actual problem.
The results show the problem we put forward is of practical significance and it can improve the utilization of containership.
Our algorithm uses greedy rules to find the best slot for each container, hence the results may be the near-optimal rather than global optimal.
As we all know, it is difficult to get the global optimal for this kind of problem.
Applying this algorithm into the real shipping management can enhance the hull space utilization and reduce some spending in the case of improving the utilization of containership.
The novelty and practicality show the importance of this paper and it can give a reference to the future study.


Furthermore, the rehandles are unavoidable in the actual port operation, which indicates the problem we propose in this paper does make some
sense and the solution we work out using our heuristic algorithm can provide a preliminary assessment for forwarders to arrange
linear shipping company for transportation.


\bibliographystyle{apalike2}
\bibliography{references}
\end{document}


